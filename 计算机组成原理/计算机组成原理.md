# 计算机组成原理

# 概论

## 1.1 计算机的基本组成

### 1、冯诺依曼计算机

特点：

1. 指令和数据以**同等地位**存放于存储器内，并可以按地址访问；
2. 指令和数据均用**二进制**表示,指令由操作码、地址码两大部分组成，
   - **指令=操作码+地址码**
   - **操作码**用来表示操作的性质，**地址码**用来表示操作数在存储器中的位置；
   - CPU根据 **指令周期的不同阶段**来区分数据和指令
     - 通常在**取地址阶段**取的是——指令
     - **执行阶段**——数据
3. 存储器、运算器、控制器、输入设备、输出设备 **5个部件**
4. **运算器**为中心
5. “**存储程序**”工作模式——**控制流驱动**
6. 基本特点：**按地址访问并顺序执行指令**
7. 是 **单处理器**

冯诺依曼计算机框架

实线—数据线
虚线——控制和反馈线 ![image-20230517145403859](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517145403859.png)


- ### **现代计算机硬件框图**

  

  - 计算机 = 主机 + 输入/输出设备
  - 主机 = CPU + 存储器
  - **CPU** = **ALU**  运算器 + **CU** 控制器
  - **存储器：存放数据和指令【存储器为核心】**

### 2.**存储器的基本组成**


![image-20230517161642598](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517161642598.png)

- **CPU能直接访问**的存储器——主存
- **主存**：按存储单元的地址进行存取——**按地址存取**
- **地址寄存器（MAR）**: 存放访存地址，反映存储单元的个数
  - 寻址，其**位数**就是**存储单元的个数**
  - **位数=存储单元的个数/地址码的长度**
  - 现代计算机的CPU中也内置了MAR
- **数据寄存器（MDR**）:暂存要从存储器中读或写的信息。反映存储的字长
  - **暂存数据，位数=存储字长**

- **存储单元**：存放一个存储字的所有存储元集合

要访问256G的主存空间，至少需要的地址线数量为38根

![image-20230517204421685](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517204421685.png)

> ![image-20230606131303852](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606131303852.png)
>
> 存储元**是存储器的最小存储单位，它的作用是用来存放一位二进制代码0或1。**
>
> 存储单元：存放一串二进制代码的空间。
> 存储字：存储单元中二进制代码的组合
> 存储字长：存储单元中二进制代码的位数（1B（8bit）或字节的偶数倍）
>
> 存储体：有许多的存储单元组成
>  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517162029197.png)


### 3.运算器的基本组成

- **功能：**用于进行算术运算和逻辑运算
- 控制单元**CU**+算术逻辑单元**ALU**=**CPU**

- **算术逻辑单元ALU——运算器的核心**
  不可少的：三个ACC+MQ+X 
  
  - 累加器**ACC**
  
  - 乘商寄存器**MQ**
  
  - 操作数寄存器 **X**                   
  -   ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517192322959.png)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
  
- 加法指令![ACC加法](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/ACC%E5%8A%A0%E6%B3%95.gif)

- 减法指令

  ![ACC减法](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/ACC%E5%87%8F%E6%B3%95.gif)

- 乘法 （MQ）ACC存高位 MQ低位

  ![ACC乘法](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/ACC%E4%B9%98%E6%B3%95.gif)

- 除法 ACC存余数 MQ存商

  ![ACC除法](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/ACC%E9%99%A4%E6%B3%95.gif)

### 4.控制器的基本结构

- **功能：**解释指挥指令+保证指令的有序执行
- **组成：**

![image-20230517193455256](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517193455256.png)

- **PC**	存放当前将要执行指令的地址，自动 **+1** 以形成下一条指令地址
- **IR**    存放当前的指令
  - 内容来自**MDR** 
  - 操作码OP(IR)送到 CU， 分析指令并发出命令序列
  - 地址码Ad(IR)送到MAR，用作取操作数

### 5.完成一条指令的过程

- 存数指令流程图

  ![image-20230517195101547](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517195101547.png)

---

取数指令流程图

  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517193719797.png)取数指令执行过程——**取指-译码-执行**

**1. 取指令：PC->MAR->M->MDR->IR**

根据PC取到指令到IR。

(1)将PC中的送MAR

(2)MAR中的内容直接送地址线，同时控制器将读信号送**读写信号线**，

(主存的操作：主存根据地址线上的地址的读信号，从指定存储单元读出指令，送到数据线上)

(3)MDR从数据线接受指令信息

(4)并传送到IR中

**2. 分析指令: OP(IR) ->CU**

(5)指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。

**3.执行指令：IR->MAR->M->MDR->ACC**          取数操作。

(6)将IR中指令的地址码送MAR

(7)MAR中的内容送地址线，同时控制器将读信号送读/写信号线，从主存指定存储单元读出操作数

(8)存储通过数据线送至MDR

(9)再传送至ACC中。

over

此外，每取完一条指令，还必须为取下一条指令做准备，形成一条指令的地址，即(PC) + 1 -> PC

---



### *程序执行过程举例*

![image-20230606141802534](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606141802534.png)

### *常见的操作码*

![image-20230606141826566](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606141826566.png)



---



## 1.2计算机性能指标

### 1.机器字长

- **CPU一次能处理数据的位数**，与CPU中的**寄存器位数**有关

- 字长越长，机器性能越好。数的表示范围越大，计算精度越高

  

### 2. 运算速度

  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517201815534.png)



- **主频** ：CPU内数字**脉冲**信号振荡的**频率**

    $CPU主频（时钟频率）=\frac{1}{CPU时钟周期}$

- **时钟周期：**CPU最小的时间单位，执行指令的每个动作至少需要1个时钟周期

- #### **CPI：**执行一条指令所需要的周期数

- **$CPI=\frac{CPU时钟周期数}{指令数}$**

  **$CPU时钟周期数=指令条数*CPI$**

  **$执行一条指令的耗时=CPI*CPU时钟周期$**

  **$CPU执行时间=时钟周期数量*时钟周期=\frac{时钟周期数}{主频}=\frac{指令条数*CPI}{主频}$**

  

  - ![capture-2023-06-06-15-20-26](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/capture-2023-06-06-15-20-26.jpg)

- **IPS：**每秒执行多少条指令

- #### MIPS:每秒执行多少百万条指令

      ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606143904987.png)

    - ![capture-2023-06-06-15-06-37](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/capture-2023-06-06-15-06-37.jpg)

- #### **FLOPS：** 每秒执行多少次浮点运算
  
  - **K**FLOPS **$10^3$**
  
  - **M**FLOPS **$10^6$**
  
  - **G**FLOPS $10^9$
  
  - **T**FLOPS **$10^{12}$**
  
  - **P**FLOPS  **$10^{15}$**
  
  - **E**FLOPS **$10^{18}$**
  
  - **Z**FLOPS **$10^{21}$**  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230518152009819.png)
  
  - 其他换算
  
    ![image-20230606143716600](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606143716600.png)



### 3.存储容量

![image-20230517202226982](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517202226982.png)
- 主存储器所能存储信息的最大容量
- 通常以**字节**来衡量【1B=8bit】
- 也可以用**字数 \*字长**表示

  - MAR为16位
    -   $2^{16}= 65536$，即存储体内有 $65536$ 个存储单元 
    -  $1K = 1024 B = 2^{10}$
    -  $\frac{65536}{1024}=64$
    - 即  **64K 个存储字数**

  - MDR为32位

  - **主存容量**(存储容量)=字数*存储字长 
    - 64K  x   32位   
    - $2^{16} *  2^5 = 2^{21}$


![2进制](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230517214124555.png)

### 综合性能指标

4. #### 吞吐量

- 指系统在单位时间内处理请求的数量。
  - 它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到**主存**，
  - 因此，系统吞吐量主要取决于**主存的存取周期。**


5. #### 数据链路带宽

- 数据总线一次所能**并行**传送信息的位数（各硬件部件通过数据总线传输数据）

6. #### 响应时间

- 指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的**等待**时间。
  - CPU时间（运行一个程序所花费的时间）
  - 等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间）

## 本章常考知识

| 存取速度：寄存器【CPU内部】 > Cache > 内存                   |
| ------------------------------------------------------------ |
| 机器语言是计算机唯一可以直接识别和执行的语言                 |
| **存储元**：即存储二进制的电子元件，每个存储元可存1bit   <br />**存储单元**：每个存储单元存放一串二进制代码<br />**存储字**：存储单元中二进制代码的组合   <br />**存储字长**：**存储单元中**二进制代码的位数  <br />**机器字长**：计算机能一次**处理的**二进制代码长度         <br />                              1.可通过**寄存器的位数判断机器字长**<br />                              2.一定与机器字长相同的部件：ALU，通用寄存器<br /> **指令字长**：**指令的**二进制长度    <br />**数据字长**：数据总线一次能并行传送信息的次数 |
| ![img](data:image/png;base64,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) |
| **IR，MAR，MDR对程序员不可见【透明】**                       |
| 计算机”**运算速度**“指标指的是每秒能执行多少条指令，即**MIPS**       <br />  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606143904987.png)|
| 描述**浮点数操作速度**的指标：**MFLOPS**                     |
| CPU执行时间<br />![image-20230606144319085](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606144319085.png) |

## 题

1. 汇编语言与机器语言的对应关系为___ 
   - 一对一







---



# 总线系统

- #### 总线

  - 是连接各个部件的信息传输线
  - 各个部件**共享**的**传输介质
  - 总线的内部结构
    - **地址线**——单向，传送主存与设备的地址
    - **数据线**——双向，传送数据
    - **控制线**——每一根单向（CPU->接口，接口->cpu），指明数据传送的方向+中断控制+定时控制等 

- #### 特点

  - **分时性**：同一时刻只允许有一个部件向总线**发送**信息；同一时刻只能有**一个主设备**控制总线的传输操作
  - **共享性**：总线上可以挂接多个部件

- #### 特性

  ![aa](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606172708603.png)

- #### 性能指标

    ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606172756603.png)

    ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606173738419.png)  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606173655795.png)

  - **总线带宽=总线工作频率×（总线位宽/8）【单位为 字节/s】**

  - **（总线带宽）（传输率）=总线宽度×总线工作频率**

- ##### 总线常用的标准

  - **PCI** ，外部设备互连，高速外围总线，并行总线
  - **USB** ，串行总线 ，高速，扩展性，连接
  - **AGP**，显卡专用总线，连接主存-图形存储器



## 总线分类

- **数据传送方式**不同

  - 分为**串行传送**和**并行传送**。

    ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606153847418.png)

- 按 时序控制方式 分 同步总线和 异步总线
- 🍅按 **功能**划分 为
  - **片内总线**
  - **系统总线**
  - **I/O总线**
  - **通信总线**

## 总线的结构

- #### 总线结构对计算机性能的影响

1. 简化了硬件的设计
   - 便于多个设备连入总线即可工作，不必考虑详细操作。
2. 简化了系统结构，便于系统的设计制造
3. 便于接口设计，所以与总线连接的设备均可采用类似的接口。
4. 便于设备软件设计，所有接口的软件对不同的接口地址进行操作
5. 系统扩充性好
   - 分别是规模扩充和功能扩充，使系统扩充既简单又快速可靠，而且也便于查错。
6. 系统更新性能好，可灵活配置，易于实现系统的模块化
7. 便于故障诊断和维修，同时也可降低成本





- 总线结构有**单总线结构** 和 **多总线结构**

### 总线结构

![image-20230606165903573](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606165903573.png)

- 组成——**系统总线**

- 优点
  - 结构简单，成本低，易于接入新的设备
- 缺点
  - 带宽低，负载重
  - 多个部件只能**争用惟一**的 **总线控制权**，会产生时延
  - 不支持 **并发** 传送操作

### 多总线结构

				分离高速、中速、低速 总线，提高**速率和吞吐量**，而且处理器结构变化**不影响高速总线**



- #### 双总线结构

  ![image-20230606171119770](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606171119770.png)

  - 组成——**主存总线+I/O总线**
  - 将**低速 I/O设备**从单总线上**分离**出来
  - 优：实现了**存储器总线**和  **I/O总线**分离
  - 缺：需要**增加通道**等硬件设备



- #### 三总线结构

  ![image-20230606171354391](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606171354391.png)

  - 组成——**主存总线+I/O总线+DMA总线（直接内存访问）**	
  - **DMA总线**—内存和 高速外设 之间能直接传送数据
  - 优：提高了I/O设备的性能，使其**更快地响应**命令，提高系统**吞吐量**
  - 缺：工作效率低

## 总线通信控制

### 总线事务

- 从**请求**总线到**完成**总线使用的**操作序列**
  - 一个总线的周期中发生的一系列活动

| 经典事务     |                                                              |
| ------------ | ------------------------------------------------------------ |
| **请求**阶段 | 主设备（CPU,DMA)总线传输请求，申请获得总线控制权             |
| **仲裁**阶段 | 总线**仲裁机构 决定** 控制权                                 |
| **寻址**阶段 | 主设备 向 从设备 **给出地址**和**命令**                      |
| **传输**阶段 | 主设备 从设备   **数据交换** <br />一般只能传输 一个字长的数据 |
| **释放**阶段 | **撤销**相关的信息                                           |

- 常考

  - **突发传送**——能够进行连续**成组**数据的传送

    - 寻址阶段发送的是**连数据单元的首地址**

      - 主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据

    - 可以**提高总线数据传输率**

      

### 总线定时/控制

|        | 同步定时（时钟信号）                                         | 异步定时（握手信号）                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义   | - 采用 **统一的时钟信号**<br /><br />同步控制既可CPU控制，又可高速的外设控制 | • 没有统一的时钟；没有固定的时间间隔（不采用时钟信号，**只采用握手**）<br/>• 完全依靠传送双方相互制约的“握手”信号来实现定时控制<br/>• 传送操作是由**双方按需求分配**时间的<br/>每次握手完成一次通信，但是一次通信往往交换多位数据 |
| 优点   | • 传送速度快，具有**较高的传输速率**<br/>• 总线控制逻辑**简单**<br/>• 同步通信**不需要应答信息且总线长度短**<br/>• 同步通信用一个公共的时钟信号进行同步<br/>同步通信中，各部件的存取时间较接近 | • 总线周期长度可变<br/>• 能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换<br/>自动适应时间的配合 |
| 缺点   | • 主从设备属于**强制性同步**<br/>• 不能及时进行数据通信的**有效性验证**<br/>• **可靠性较差** | 比同步稍复杂一些，**速度比同步方式慢**                       |
| 适用于 | **总线长度较短**及**总线所接部件的存储时间比较接近**的系统   | 不同设备间的通信                                             |

#### 异步定时

![image-20230606181248487](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606181248487.png)

![image-20230606181348800](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230606181348800.png)



---

## 题

1. **DMA总线**用于 **主存与I/O设备** 之间交换信息

   

2. 在计数器定时查询方式下，若每次计数都是从0开始，则___

   - 设备号越小优先级越高

     

3. 按连接部件不同可以对总线分为三大类，其中不属于这三类的是___

   - **解析：** **片内总线、系统总线和通信总线**为按连接部件不同对总线的分类。

   - 存储总线为在单总线基础上又开辟出的一条CPU与主存之间的总线。

     

4. ‎下列**不属于**集中控制优先权仲裁方式的为 **同步查询**

   

5. ‌在计算机的总线中，**不同信号在同一条信号线**上**分时**传输的方式称为  **总线复用**

   - **解析：** 指的是数据和地址在同一个总线上传输的方式。既同一条信号线上分时传输不同的信号。

     

6. 在总线上，某一时刻只允许**一个**部件向总线发送信息，但多个部件可以同时从总线上接收相同的信息

   

7. ‍在各种异步通信方式中，  **不互锁**速度最快。

   

8. ‏系统总线是连接计算机内各大部件的信息传输线，该总线按传输内容的不同又分为 **地址总线** 和 **数据总线**





---



# 存储系统

## 存储器概述

### 存储器的分类

#### 按 作用 分类

![image-20230628103224955](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628103224955.png)

- 主存
  - 容量较小，存取速度较快，价格较高
  - 用来存放计算机运行期间所需的程序和数据
- 辅存
  - 容量大，存取速度较慢，单位成本低
  - 用来存放当前暂时不用的程序和数据以及一些需要永久性保存的信
  - 辅存的内容**需要调入主存后才能被CPU访问**
  



#### 按介质分类

1. **半导体存储器**（TTL、MOS）（MOS型存储器、双极型存储器）——**易失**

2. **磁表面存储器**（磁盘、磁带）

3. **磁芯存储器**

4. **光存储器**（光盘）

   

#### 按 存取方法 分类

1. **随机访问**（存取时间与物理地址**无关**）

   - 随机存取就好像素数可以通过下标直接访问需要的元素

   - **ROM 和 RAM 都是采用随机方式访问信息**，ROM 只能进行取，RAM 可取可存

   - **随机存储器RAM**——执行过程中 **可读可写**

     - 读写方便，使用灵活
     - RAM分为静态RAM和动态RAM
     - RAM主要为用户编程设置的
     - 存储器的任何一个存储单元都可以随机存取
     - **主要用于做 主存 或 高速缓冲存储器Cache**

   - **只读存储器ROM**——执行过程中 **只读**

     - ROM与RAM一起统一构成主存的**地址域**
     
     - 操作系统的内存储器既有RAM也有ROM
     
     - 广义上的ROM现在可通过**电擦除**进行写入
     
     - **信息一旦写入就不变，断电后也不消失**
     
     - 通常用于存放**固定不变的程序**，常数和汉字字库——ROM存放**系统程序**，标准子程序和各类常数
     
       - CD-ROM 只读光盘
       
     

2. **串行访问**（存取时间与物理地址**有关**）

   - **顺序存取存储器——磁带**	
     
     - 存取速度慢
     - 只能按某种顺序存取
   - **直接存取存储器——磁盘**   光盘
     
     - 既不是随机存取也不是按顺序存取
     
     
     

####  按信息可保持性

   - 易失性存储器
     - 断电后，存储信息消失【如RAM】

   - 非易失性存储器
     - 断电后，信息仍保存【如ROM，磁表面存储器，光存储器】




---


## 存储器的层次结构

![image-20230628103255405](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628103255405.png)

![image-20230628103352674](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628103352674.png)



   - 有主存的速度，辅存的容量和价格

   - 程序的局部性原理

- #### 信息和数据交互

  - Cache和**主存**——能与CPU**直接交换信息**

  - **辅存**要通过**主存**——与CPU交换信息；

  - **主存与CPU，Cache，辅存都能交换信息**

- ### 层级结构

1. **缓存-主存**  

     - 硬件方法连接 透明的
    - 解决CPU和主存**速度不一致的问题**
     - 数据调动是由**硬件**自动完成的，**对所有程序员透明**
2. 主存和CPU之间**增加高速缓冲存储器**Cache**的目的是
     -  - 解决CPU和主存之间的**速度匹配问题**

3. **主存-辅存**  
     - 虚拟存储——虚地址 远大于内存地址
     - 解决**存储系统的容量问题**
     - 数据调动是由**操作和os****共同完成**的【换入换出技术】 ——对应用程序员透明

## 主存储器

- 主存储器即主存，**存储指令和数据，由RAM和ROM实现**
- 主存储器**在CPU外，按地址访问**
- 控制存储器用来**存放实现指令系统的所有微指令**，由**ROM实现**
- 控制存储器在**CPU的控制器内**，按照**微指令的地址访问**

### 基本组成

![image-20230628104420826](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628104420826.png)

- CPU与主存之间的关系

  ![image-20230628104513512](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628104513512.png)



## 半导体存储器

- 半导体存储器的特点
  1. 体积小
  2. 具有易失性
  3. 功耗低
  4. 存取时间短

### 半导体芯片的基本组成

![image-20230628105317696](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628105317696.png)

- 芯片的容量

  - 数据线——双向

  - 地址线——单向

  - 若主存每个存储单元存放16位二进制代码，则——其地址线数与16**无关**

    ![image-20230628105419808](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628105419808.png)

- 片选线——芯片选择线 

  - CS是选择线

  - CE是使能信号

    ![image-20230628105346685](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628105346685.png)

- 读写控制线





### 半导体存储芯片的译码驱动方式

#### 线选法

#### 重合法

## 随机存储存储器

### 静态RAM（SRAM）

1. 保存0和1的原理是什么——**双稳态触发器**，（六晶体管MOS）
2. 特点是什么
   - **存取速度快**
   - **但** 集成低，功耗大，价格昂贵，
3. 主要用途——**高速缓冲存储器**



![image-20230628105721802](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628105721802.png)

### 动态RAM（DRAM）

1. 保存0和1的原理是什么——**电容**（利用存储元电路中栅极电容上的电荷）（1个晶体管）
2. 特点是什么
   - **任意集成，功耗低，价位低，容量大**
   - 但 存储速度相对SRAM较慢
   - 需要刷新，**破坏性读出**

- ### 刷新

  1. 多久刷新一次？
     - 刷新周期，一般为2ms
  2. 每次刷新多少存储单元？
     - 以行为单位，每次刷新一行存储单元
     - 以行列地址的——> 减少选通线的数量
  3. 如何刷新？
     - 有硬件支持，读出一行的信息后重新写入，占1个读写周期

- 理解参考：https://blog.csdn.net/peng0614/article/details/120816492

  - **集中**刷新

    - 一个刷新周期，一段**固定的时间**依次对存储器的**所有行逐一刷新**

      - 优：读写操作不受刷新影响
    - 缺：刷新时死区不能访问存储器
  
    - 示例

      - 256行 x 256列
    - 存取周期：0.5us
      - 刷新周期：4ms
  
      ![image-20230628112530102](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628112530102.png)

  - **分散**刷新

    - 把每一行的刷新分散到各个工作周期

      - 前半部分 读写 + 后半部分 刷新
    - 优：没有死区
      - 缺：加长了存取周期，降低 整体速度
  
      ![image-20230628112508789](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628112508789.png)

  - **异步**刷新

    - 把每行刷新分散到一整个刷新周期中去

      - 避免CPU连续等待过长，减少刷新次数
    - 从根本上提高了整机的工作效率
  
        ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628113127488.png)

- **注意点**

  1. **刷新对CPU是透明的**，即刷新不依赖外部访存

### 比较

![image-20230628204453848](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628204453848.png)

![image-20230630163139373](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230630163139373.png)





## 只读存储器ROM

- 常见类型

  1. **MROM**

     掩模式只读存储器

     -  芯片制造商生产过程中直接写入，之后**无法改变**其内容

  2. **PROM**

     **一次可编辑**只读存储器

     - 允许用户用专门的设备写入程序，写入后无法改变内容

  3. **EPROM**

     可擦除可编程只读存储器

     - 允许用户写入程序，用户可对其程序进行**多次改写**；需要修改时，要将其全部擦除**（不可局部擦除）**
     - 修改次数有限，写入时间长

     4. **EEPROM**

        - 电擦除，和EPROM允许原理一样，但既**可局部擦除**，又可全部擦除

          

  4. **Flash存储器(闪存)**

     - 在不加电时仍**可长期保存**信息且**快速的擦除重写**

     - 写的速度 比 读的速度更慢，因为写之前要先擦除

     - U盘，U盘采用的是 Flash存储器技术，是ROM的一种，写入速度较快，擦除速度和性价比均可观，常用作辅存

     - 闪存必须在空白区域写，**如果目标区域已经有数据，先擦除后写**，而读不必如此

     - 断点信息不丢失，是非易失性存储器

     - 随机访问，可替代外部存储

       

  6. **SSD 固态硬盘**
     -  可长期保存信息、快速擦除、重写、读写速度快、低功耗————但贵
     -  **控制单元+FLASH芯片**

  

- 重要的ROM

  - **BIOS芯片**

  	存储了"自举装入程序"，负责引入装入操作系统（开机）

  







## 主存与cpu的连接

### 主存容量的扩展

#### 1.位扩展

- 目的：芯片容量有限，**扩位，增加存储字长**，使   数据位数=CPU线数

- 连接方式：将多个存储芯片的地址端、**片选端**和读写控制端相应并联，数据端分别引出

  ![image-20230628205704667](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628205704667.png)

#### 2.字扩展

- 增加存储器中的字的数量，扩字，位数不变

- 将芯片地址端、**数据端**、读写控制线相应并联、片选信号区分芯片的地址范围

  ![image-20230628205629817](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628205629817.png)
  
- | 线选法                 | 译码片选法             |
  | ---------------------- | ---------------------- |
  | n条线>n个选片信号      | n条线>2n个选片信号     |
  | 电路简单地址空间不连续 | 电路复杂地址空间可连续 |

  

#### 3.字位同时扩展

- 同时扩展字和位，既增加存储字长又增加存储字数量

![image-20230628205332765](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230628205332765.png)



## 多模块存储器

- 一种**空间并行技术**，利用多个结构完全相同的存储模块的并行工作来**提高存储器的吞吐率**

### 单体并行存储器

​			存储器中只有一个存储体，每个存储单元存储m个字，总线宽也为m个字，地址必须**顺序排列**并**处于同一存储单元**

- 通俗理解

  - 换一台多列的快递柜而不能理解为多个一列的快递柜放在一起

- 过程

  ​		 在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU

- 缺点

  ​			指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显



### 多体并行存储器

​			由多体模块组成，每块都有**相同容量和读取速度**，各模块都有**独立的读写控制电路、MAR和MDR**。既能并行工作也能交叉工作。

- 通俗理解
  - 把多个单列的快递柜拼放在一起，通过加上一些控制电路把他们连接起来，这种叫多体并行存储器。



#### 高位交叉编址（顺序方式）【竖】

  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230707080429413.png)

- **先在一个模块内访问**，等到该模块**访问完之后才转到下一个模块访问**

- #### 编号

  - 高位地址表示**体号【模块号】**，低位地址表示**体内地址**

- 优点
  1. 某个模块进行存取时，其它模块不工作
  2. 某一模块出现故障时，其它模块可以照常工作
  3. 通过增添模块来扩充存储器容量比较方便

- 缺点
  - 各模块串行工作，存储器的**带宽受到了限制**，**并不能提高吞吐量**





#### 低位交叉编址（交叉方式）【横】

![image-20230707075541947](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230707075541947.png)

- 特点

  - 连续地址分布在相邻的不同模块内，同一模块内的地址是不连续的
  - 地位交叉编制是交叉存放的，满足程序的局部性原理

- #### 编号

  - 高位地址表示体内地址，低位地址表示**体号【模块号】**

- 优点
  - 对连续字的成块传送可实现多模块并行存取，提高了存储器的带宽

#####   【计算】

  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230707080112321.png)

  1. #### 每个模块按**“模m”交叉编址**，**模块号=单元地址%m**

  2. 设模块字长等于数据总线宽度，模块存取一个字的存取周期为T，总线传输周期为r

     则存储器交叉模块的数目**最小为m=T/r**

  3. 每隔r 时间延迟后启动下一模块，当数目不小于m时，就可以保证T时间之后再启动该模块，流水线就不会断

  4. ##### 取m个字的时间为T+(m-1)r，顺序方式时间为mT

  5. ##### 判断发送访问冲突的规则：给定的访存地址在**相邻的四次访问**中出现在同一个存储模块中**【m=4时】**

- 常考题

  - m位交叉编址，**$模块号=单位地址 % m$**

  - 存取周期=传输周期+恢复周期

  - $m（最小）=\frac{存取周期}{传输周期}=\frac{T}{r}$

  - 模块数=4，存储周期T，字长W，数据总线宽度即为W，总线传输周期r，连续存取n个字，分别求带宽

  - 翻译：有m个存储体，存储周期为T，字长为W，每隔r时间启动下一个存储体，连续存取n个字，分别求带宽

  - #### 带宽=存取速率$=\frac{总量}{时间}=\frac{nm}{t}$

    - 顺序 $t=mT$				交叉$t=T+(m-1)r$

---



## 外部存储器

## 	Cache存储器

参考博客：https://blog.csdn.net/qq_43663263/article/details/102797565

- #### 主存地址及缓存地址

![image-20230703161557747](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230703161557747.png)



### 概念及原理

1. ##### 引入目的：解决CPU和主存速度不匹配的矛盾

2. ##### 原理

   - Cache就是存在于主存与CPU之间的一级存储器

     - 有了它**CPU可以直接对其存取数据**，从而减少了时间，提高了系统的运行速度

   - ##### 信息交互

     - **CPU**与**Cache/主存**的信息**交互单位为字**
     - **Cache与主存**的信息交互单位为**块**，一个块通常由若干字组成，块的大小相同，块内地址相同	

- ##### 局部性原理

     - 时间局部性
       - 指如果程序中的某条指令一旦执行，则不久之后该指令可能**再次被执行**；如果某数据被访问，则不久之后该数据可能再次被访问
       - 例如循环
     - 空间局部性
       - 指一旦程序访问了某个存储单元，则不久之后。其**附近的存储单元**也将被访问
       - 例如对数组的访问，如果数组按行存的，则先行再列的取方式空间局部性更好		

### 性能分析

- 命中

  - 主存块**调入** Cache
  - 主存块与Cache块建立了对应的关系

  - 用**标记记录**与Cache块建立了对应关系的**主存块号**
    - 标记位—主存块号—对应关系

- #### Cache命中率

  - 与cache的**容量**和**块长**有关
  
    $Cache命中率   H =\frac{总命中次数}{(总命中次数+访问主存次数)}=\frac{Nc}{Nc+Nm}$

- #### 缺失率

     $Cache缺失率=1-H(命中率)$

- #### 平均访问时间

  $平均访问时间 T_a= 命中率×命中时间+缺失率×未命中时主存的访问时间=H*tc+(1-H)*tm$

  $T_a= 命中率×命中所需要花费的时间+缺失率×平均访存次数×一次总线读突发总线事务所需时间$

- #### 性能效率

  			$	r=\frac{主存存取周期}{Cache存取周期}=\frac{t_m}{t_c}$

  $性能效率 e=\frac{访问Cache的时间}{平均访问时间}=\frac{t_c}{t_a}\\=\frac{1}{h+(1-h)r}=\frac{1}{r+(1-r)h}$

  ​		

  

  

---

### Cache的基本结构

![Cache基本结构](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/Cache%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84-16883755839565.png)

##### Cache的读操作

![image-20230703171403854](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230703171403854.png)

##### Cache的写操作（Cache与主存的一致性）

- #### 全写法（写直达法）

  - 数据既写入Cache又写入主存

  - **写操作时间就是访问主存的时间**，Cache块退出时，**不需要**对主存执行写操作，更新策略比较容易实现

    

- #### 回写法

  - **只把数据写入Cache** 而不写入主存
  - 当Cache数据**被替换出去时 ** 才**写回主存**
  - 写操作时间就是访问主存的时间，Cache块退出时，**被替换的块需要写回主存**，增加了复杂度







---

### 地址映射

- ##### 解决：主存块如何存放在Cache中，如何将主存地址转换为Cache地址



### 直接映射（对号入座）

- 主存数据块只能装入到Cache中**规定的位置**

- #### 映射关系                     $ Cache行号=主存块号 mod  Cache行数$

  - 假设Cache有16行，根据$100 mod 16=4$，即主存第100行映射到cache的第4行中。

-  优点
  - 简单、成本低、易实现
  - 由于物理位置也是相邻的所以地址变换速度快
  - 不需要替换算法
- 缺点
  - 映射方式不够灵活
  - 空间利用率最低
  - 块冲突概率最高

  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230703173329354.png)

| t      | 别名：【主存区号】【Tag位】【主存字块标记】   <br /> 通过主存区的标记位数就能知道这个cache是属于主存的第几区   <br /> t = 主存地址长度 - Cache地址长度          <br />t = 主存大小/Cache大小 |
| ------ | ------------------------------------------------------------ |
| c      | Cache块的地址位数    如有1k个Cache行，则Cache块的地址位数=c=10 |
| m      | 主存块的地址位数    如有1k个主存块，则主存块的地址位数=m=10  |
| b      | 块内地址位数    如块的大小为32B，按字节编制，块内地址位数=b=5 |
| 有效位 | 每个Cache行一般都有一个有效位，判断Cache是否命中【计算位数一定要加上】  <br />有效位的作用是指出所在Cache行中的信息是否有效 |
| 脏位   | 如果是回写策略，则需要1个脏位【题目有回写策略记得加上】      |
| LRU位  | 如果有用LRU替换算法，则增加一位LRU位                         |
| 其他   | m = t + c     m=主存地址长度 - b          **主存地址长度 = t + c + b** |

- **【主存地址长度】主存中存储单元个数为 2^10^,则主存地址长度就是10**  = t + c + b
- **【Cache地址长度】Cache中存储单元个数为 2^10^,则Cache地址长度就是10** 
- **【Cache行的总位数】 = 标记位数t + 数据位 + 1位有效位 + 1位脏位(回写策略)**

-   ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230705110718108.png" alt="image-20230705110718108)

  

  **例题：设主存容量 1MB，Cache容量 16KB，块大小为 512B，采用直接映射方式。**

  1. 写出**Cache的地址格式：**

     >   ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230705104348497.png)
     >
     > ①	Cache容量=16 KB=2^14^ B	——> 则 Cache的总位数=14位
     > 	
     > ②	块大小=行大小=512B=2^9^ B	——>则 **行内地址b=9**
     > 	
     > ③	**cache行标记位c=14-9=5 位**——>则 Cache共有	2^5^=32行

     

  2. 写出**主存地址格式** ：

  >   ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230705104938900.png)
  >
  > ①	主存容量=1MB=2^20^ B	——> 则 主存的总位数=20位
  > 	
  > ②	块大小=512B=2^9^ B	——>则 **块内地址 b=9**
  > 		
  > ③	**主存块号 m=20-9=11**	——>则 主存共有 2^11^=2048块
  > 		
  > ④	**m= t (主存标记)+ c (cache行号)=11**
  > 		
  > ⑤	由上题得出 c=5，则**主存标记位 t =m-c=11-5=6位**

  







---



###  全相联映射（空位随意放）

- ##### 可以把主存数据块装入Cache中的**任何位置**

- 优点：
  - Cache存储空间利用充分，命中率高，映射灵活，块冲突概率比较低
- 缺点：
  - 成本高，速度慢耗时多（需要找标记）

  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230703181818328.png)

全相联中的t,c,b,m和直接映射中的都一样

  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230705110803056.png)

**例题：设主存容量 1MB，Cache容量 16KB，块大小为 512B，采用全相联映射方式。**

1. 写出**Cache的地址格式：**

   >   ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230705100428855.png)
   >
   > 跟直接映射步骤相同

   

2. 写出**主存地址格式** ：

   >   ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230705100047108.png)
   >
   > ①	主存容量=1MB=2^20^ B	——> 则 主存的总位数=20位
   > 	
   > ②	块大小=512B=2^9^ B	——>则 **块内地址 b=9**
   > 	
   > ③	**主存块号 m=20-9=11**	——>则 主存共有 2^11^=2048块



---



###  组相联映射（按号分组，组内任意放）

  ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230703181805595.png)

- ##### 将Cache分为若干组、组间直接映射、组内全相联映射

|   2^c^   | Cache的总块数                                         |
| :------: | ----------------------------------------------------- |
| **2^q^** | Cache分组个数     【分组个数 = 分块个数/组内块数】    |
| **2^r^** | 组内包含的块数     【r=1，每组包含2块，叫二路组相联】 |
|          | **s = t + r    q = c - r**                            |

 ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230705115613765.png)

**例题：一个组相联Cache由 64个行组成，每组4行。主存储器包含4K个块，每块128字。**

写出**内存地址**的格式：

> 🤍
>
> 由题意得
>
>   ![a](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230705172845095.png)
>
> ①	主存的总块数=2^m^=4K	——>	4K=2^12^	——>m=12 
>
> ② 	块大小=128字=2^7^	——> **块内地址b=7**
>
> ③	每组4行 	——> 	r=4
>
> ④	Cache由 64个行组成	——>    总行数=64=r*Q(组数)	——>**求出组数 Q=64/4=16组** 	
>
> ⑤	分组数=2^q^  ——>则 16=2^4^	——>  求出**Cache组号 q=4**  
>
> ⑥	m=q+s   则 主存标记位 **s=m-q=12-4=8**





![image-20230705182924590](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230705182924590.png)



### 替换算法

| 随机算法         |         随机确定被替换Cache块          |
| :--------------- | :------------------------------------: |
| 先进先出FIFO     |        选择最早调入的块进行替换        |
| 近期最少使用LRU  |    选择近期内长久未访问的块进行替换    |
| 最不经常使用 LFU | 将一段时间内被访问次数最少的存储行换出 |



### 写策略

写入/更新策略——如何既保证主存块和Cache块的数据一致性，又尽量提升效率

- 直写法
  - 写操作时把数据同时写入主存和Cache
- 写回法
  - 写操作只把数据写入Cache，而不写回主存，只有当Cache数据被替换时，才写回主存



## 虚拟存储器









# 指令系统

## 指令格式

![image-20230708175136230](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230708175136230.png)



![image-20230708175301755](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230708175301755.png)

![image-20230708175149604](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230708175149604.png)

![image-20230708175204880](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20230708175204880.png)

- #### 定长操作码:

  - 在指令字的**最高位部分**分配**固定的若干位**(定长)

  - **n位操作码最大能表示2^n^条指令**

  - **优**：定长操作码对于简化计算机硬件设计，提高指令**译码和识别速度**很有利

  - **缺**：指令数量增加时会**占用更多固定位**，留给表示操作数**地址的位数受限**。

    

- #### 扩展操作码(不定长操作码):

  - 全部指令的操作码字段的**位数不固定**，且**分散**地放在指令字的**不同位置上**
  - 最常见的变长操作码方法是
    - **扩展操作码**，**地址码的减少——>地址码长度增加**
    - 不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。
  - **优**：在指令字长有限的前提下仍**保持**比较丰富的**指令种类**;
  - **缺**：增加了指令**译码和分析的难度**，使控制器的设计**复杂化**。
